// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: application/applet/rpc/desc/applet.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	//  获取用户信息
	GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error)
	// 获取Token
	GetUserToke(ctx context.Context, in *GetUserTokeRequest, opts ...grpc.CallOption) (*GetUserTokeResponse, error)
	// 分页获取用户列表
	GetUserList(ctx context.Context, in *GetUserListRequest, opts ...grpc.CallOption) (*GetUserListResponse, error)
	// 新增（注册）用户 - 管理员
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	// 修改用户信息
	UpdateUserInfo(ctx context.Context, in *UpdateUserInfoRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 修改用户和角色的关系信息 -- 和上  在修改用户信息的时候请求
	UpdateUserAuthorities(ctx context.Context, in *UpdateUserAuthoritiesRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 重置用户密码 默认密码：goZero
	ResetUserPassword(ctx context.Context, in *ResetUserPasswordRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 删除用户
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) GetUserInfo(ctx context.Context, in *GetUserInfoRequest, opts ...grpc.CallOption) (*GetUserInfoResponse, error) {
	out := new(GetUserInfoResponse)
	err := c.cc.Invoke(ctx, "/pb.User/GetUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUserToke(ctx context.Context, in *GetUserTokeRequest, opts ...grpc.CallOption) (*GetUserTokeResponse, error) {
	out := new(GetUserTokeResponse)
	err := c.cc.Invoke(ctx, "/pb.User/GetUserToke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUserList(ctx context.Context, in *GetUserListRequest, opts ...grpc.CallOption) (*GetUserListResponse, error) {
	out := new(GetUserListResponse)
	err := c.cc.Invoke(ctx, "/pb.User/GetUserList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, "/pb.User/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateUserInfo(ctx context.Context, in *UpdateUserInfoRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.User/UpdateUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateUserAuthorities(ctx context.Context, in *UpdateUserAuthoritiesRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.User/UpdateUserAuthorities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ResetUserPassword(ctx context.Context, in *ResetUserPasswordRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.User/ResetUserPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.User/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	//  获取用户信息
	GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error)
	// 获取Token
	GetUserToke(context.Context, *GetUserTokeRequest) (*GetUserTokeResponse, error)
	// 分页获取用户列表
	GetUserList(context.Context, *GetUserListRequest) (*GetUserListResponse, error)
	// 新增（注册）用户 - 管理员
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	// 修改用户信息
	UpdateUserInfo(context.Context, *UpdateUserInfoRequest) (*NoDataResponse, error)
	// 修改用户和角色的关系信息 -- 和上  在修改用户信息的时候请求
	UpdateUserAuthorities(context.Context, *UpdateUserAuthoritiesRequest) (*NoDataResponse, error)
	// 重置用户密码 默认密码：goZero
	ResetUserPassword(context.Context, *ResetUserPasswordRequest) (*NoDataResponse, error)
	// 删除用户
	DeleteUser(context.Context, *DeleteUserRequest) (*NoDataResponse, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) GetUserInfo(context.Context, *GetUserInfoRequest) (*GetUserInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserServer) GetUserToke(context.Context, *GetUserTokeRequest) (*GetUserTokeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserToke not implemented")
}
func (UnimplementedUserServer) GetUserList(context.Context, *GetUserListRequest) (*GetUserListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserList not implemented")
}
func (UnimplementedUserServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserServer) UpdateUserInfo(context.Context, *UpdateUserInfoRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedUserServer) UpdateUserAuthorities(context.Context, *UpdateUserAuthoritiesRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserAuthorities not implemented")
}
func (UnimplementedUserServer) ResetUserPassword(context.Context, *ResetUserPasswordRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetUserPassword not implemented")
}
func (UnimplementedUserServer) DeleteUser(context.Context, *DeleteUserRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/GetUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUserInfo(ctx, req.(*GetUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUserToke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserTokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUserToke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/GetUserToke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUserToke(ctx, req.(*GetUserTokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/GetUserList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUserList(ctx, req.(*GetUserListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/UpdateUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateUserInfo(ctx, req.(*UpdateUserInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateUserAuthorities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserAuthoritiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateUserAuthorities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/UpdateUserAuthorities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateUserAuthorities(ctx, req.(*UpdateUserAuthoritiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ResetUserPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetUserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ResetUserPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/ResetUserPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ResetUserPassword(ctx, req.(*ResetUserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserInfo",
			Handler:    _User_GetUserInfo_Handler,
		},
		{
			MethodName: "GetUserToke",
			Handler:    _User_GetUserToke_Handler,
		},
		{
			MethodName: "GetUserList",
			Handler:    _User_GetUserList_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _User_Register_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _User_UpdateUserInfo_Handler,
		},
		{
			MethodName: "UpdateUserAuthorities",
			Handler:    _User_UpdateUserAuthorities_Handler,
		},
		{
			MethodName: "ResetUserPassword",
			Handler:    _User_ResetUserPassword_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _User_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "application/applet/rpc/desc/applet.proto",
}

// MenuClient is the client API for Menu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuClient interface {
	// 获取菜单-路由
	GetMenuTree(ctx context.Context, in *GetMenuTreeRequest, opts ...grpc.CallOption) (*GetMenuTreeResponse, error)
	// 获取系统基础菜单列表
	GetMenuBaseInfoList(ctx context.Context, in *NoDataResponse, opts ...grpc.CallOption) (*GetMenuBaseInfoListResponse, error)
	// 添加系统基础菜单列表
	AddMenuBase(ctx context.Context, in *AddMenuBaseRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 获取用户动态路由树  -- 用于角色管理的设置权限
	GetBaseMenuTree(ctx context.Context, in *NoDataResponse, opts ...grpc.CallOption) (*GetBaseMenuTreeResponse, error)
	// 获取指定角色menu  -- 用于角色管理的设置权限
	GetMenuAuthority(ctx context.Context, in *GetMenuAuthorityRequest, opts ...grpc.CallOption) (*GetMenuAuthorityResponse, error)
	// 根据id获取系统菜单
	GetBaseMenuById(ctx context.Context, in *GetBaseMenuByIdRequest, opts ...grpc.CallOption) (*GetBaseMenuByIdResponse, error)
	// 更新系统菜单
	UpdateBaseMenu(ctx context.Context, in *UpdateBaseMenuRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 删除系统菜单
	DeleteBaseMenu(ctx context.Context, in *DeleteBaseMenuRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
}

type menuClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuClient(cc grpc.ClientConnInterface) MenuClient {
	return &menuClient{cc}
}

func (c *menuClient) GetMenuTree(ctx context.Context, in *GetMenuTreeRequest, opts ...grpc.CallOption) (*GetMenuTreeResponse, error) {
	out := new(GetMenuTreeResponse)
	err := c.cc.Invoke(ctx, "/pb.Menu/GetMenuTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetMenuBaseInfoList(ctx context.Context, in *NoDataResponse, opts ...grpc.CallOption) (*GetMenuBaseInfoListResponse, error) {
	out := new(GetMenuBaseInfoListResponse)
	err := c.cc.Invoke(ctx, "/pb.Menu/GetMenuBaseInfoList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) AddMenuBase(ctx context.Context, in *AddMenuBaseRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Menu/AddMenuBase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetBaseMenuTree(ctx context.Context, in *NoDataResponse, opts ...grpc.CallOption) (*GetBaseMenuTreeResponse, error) {
	out := new(GetBaseMenuTreeResponse)
	err := c.cc.Invoke(ctx, "/pb.Menu/GetBaseMenuTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetMenuAuthority(ctx context.Context, in *GetMenuAuthorityRequest, opts ...grpc.CallOption) (*GetMenuAuthorityResponse, error) {
	out := new(GetMenuAuthorityResponse)
	err := c.cc.Invoke(ctx, "/pb.Menu/GetMenuAuthority", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetBaseMenuById(ctx context.Context, in *GetBaseMenuByIdRequest, opts ...grpc.CallOption) (*GetBaseMenuByIdResponse, error) {
	out := new(GetBaseMenuByIdResponse)
	err := c.cc.Invoke(ctx, "/pb.Menu/GetBaseMenuById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) UpdateBaseMenu(ctx context.Context, in *UpdateBaseMenuRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Menu/UpdateBaseMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) DeleteBaseMenu(ctx context.Context, in *DeleteBaseMenuRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Menu/DeleteBaseMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServer is the server API for Menu service.
// All implementations must embed UnimplementedMenuServer
// for forward compatibility
type MenuServer interface {
	// 获取菜单-路由
	GetMenuTree(context.Context, *GetMenuTreeRequest) (*GetMenuTreeResponse, error)
	// 获取系统基础菜单列表
	GetMenuBaseInfoList(context.Context, *NoDataResponse) (*GetMenuBaseInfoListResponse, error)
	// 添加系统基础菜单列表
	AddMenuBase(context.Context, *AddMenuBaseRequest) (*NoDataResponse, error)
	// 获取用户动态路由树  -- 用于角色管理的设置权限
	GetBaseMenuTree(context.Context, *NoDataResponse) (*GetBaseMenuTreeResponse, error)
	// 获取指定角色menu  -- 用于角色管理的设置权限
	GetMenuAuthority(context.Context, *GetMenuAuthorityRequest) (*GetMenuAuthorityResponse, error)
	// 根据id获取系统菜单
	GetBaseMenuById(context.Context, *GetBaseMenuByIdRequest) (*GetBaseMenuByIdResponse, error)
	// 更新系统菜单
	UpdateBaseMenu(context.Context, *UpdateBaseMenuRequest) (*NoDataResponse, error)
	// 删除系统菜单
	DeleteBaseMenu(context.Context, *DeleteBaseMenuRequest) (*NoDataResponse, error)
	mustEmbedUnimplementedMenuServer()
}

// UnimplementedMenuServer must be embedded to have forward compatible implementations.
type UnimplementedMenuServer struct {
}

func (UnimplementedMenuServer) GetMenuTree(context.Context, *GetMenuTreeRequest) (*GetMenuTreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuTree not implemented")
}
func (UnimplementedMenuServer) GetMenuBaseInfoList(context.Context, *NoDataResponse) (*GetMenuBaseInfoListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuBaseInfoList not implemented")
}
func (UnimplementedMenuServer) AddMenuBase(context.Context, *AddMenuBaseRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMenuBase not implemented")
}
func (UnimplementedMenuServer) GetBaseMenuTree(context.Context, *NoDataResponse) (*GetBaseMenuTreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaseMenuTree not implemented")
}
func (UnimplementedMenuServer) GetMenuAuthority(context.Context, *GetMenuAuthorityRequest) (*GetMenuAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuAuthority not implemented")
}
func (UnimplementedMenuServer) GetBaseMenuById(context.Context, *GetBaseMenuByIdRequest) (*GetBaseMenuByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBaseMenuById not implemented")
}
func (UnimplementedMenuServer) UpdateBaseMenu(context.Context, *UpdateBaseMenuRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBaseMenu not implemented")
}
func (UnimplementedMenuServer) DeleteBaseMenu(context.Context, *DeleteBaseMenuRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBaseMenu not implemented")
}
func (UnimplementedMenuServer) mustEmbedUnimplementedMenuServer() {}

// UnsafeMenuServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServer will
// result in compilation errors.
type UnsafeMenuServer interface {
	mustEmbedUnimplementedMenuServer()
}

func RegisterMenuServer(s grpc.ServiceRegistrar, srv MenuServer) {
	s.RegisterService(&Menu_ServiceDesc, srv)
}

func _Menu_GetMenuTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenuTreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenuTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/GetMenuTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenuTree(ctx, req.(*GetMenuTreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetMenuBaseInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoDataResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenuBaseInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/GetMenuBaseInfoList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenuBaseInfoList(ctx, req.(*NoDataResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_AddMenuBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMenuBaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).AddMenuBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/AddMenuBase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).AddMenuBase(ctx, req.(*AddMenuBaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetBaseMenuTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoDataResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetBaseMenuTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/GetBaseMenuTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetBaseMenuTree(ctx, req.(*NoDataResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetMenuAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenuAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenuAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/GetMenuAuthority",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenuAuthority(ctx, req.(*GetMenuAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetBaseMenuById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBaseMenuByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetBaseMenuById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/GetBaseMenuById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetBaseMenuById(ctx, req.(*GetBaseMenuByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_UpdateBaseMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBaseMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).UpdateBaseMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/UpdateBaseMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).UpdateBaseMenu(ctx, req.(*UpdateBaseMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_DeleteBaseMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBaseMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).DeleteBaseMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/DeleteBaseMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).DeleteBaseMenu(ctx, req.(*DeleteBaseMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Menu_ServiceDesc is the grpc.ServiceDesc for Menu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Menu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Menu",
	HandlerType: (*MenuServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMenuTree",
			Handler:    _Menu_GetMenuTree_Handler,
		},
		{
			MethodName: "GetMenuBaseInfoList",
			Handler:    _Menu_GetMenuBaseInfoList_Handler,
		},
		{
			MethodName: "AddMenuBase",
			Handler:    _Menu_AddMenuBase_Handler,
		},
		{
			MethodName: "GetBaseMenuTree",
			Handler:    _Menu_GetBaseMenuTree_Handler,
		},
		{
			MethodName: "GetMenuAuthority",
			Handler:    _Menu_GetMenuAuthority_Handler,
		},
		{
			MethodName: "GetBaseMenuById",
			Handler:    _Menu_GetBaseMenuById_Handler,
		},
		{
			MethodName: "UpdateBaseMenu",
			Handler:    _Menu_UpdateBaseMenu_Handler,
		},
		{
			MethodName: "DeleteBaseMenu",
			Handler:    _Menu_DeleteBaseMenu_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "application/applet/rpc/desc/applet.proto",
}

// AuthorityClient is the client API for Authority service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthorityClient interface {
	// 获取角色列表
	GetAuthorityList(ctx context.Context, in *GetAuthorityListRequest, opts ...grpc.CallOption) (*GetAuthorityListResponse, error)
	// 增加base_menu和角色关联关系 -- 用于角色管理的设置权限
	AddAuthorityMenu(ctx context.Context, in *AddAuthorityMenuRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 更新角色 -- 设为首页
	UpdateAuthority(ctx context.Context, in *UpdateAuthorityRequest, opts ...grpc.CallOption) (*UpdateAuthorityResponse, error)
	// 创建角色
	CreateAuthority(ctx context.Context, in *CreateAuthorityRequest, opts ...grpc.CallOption) (*CreateAuthorityResponse, error)
	// 删除角色
	DeleteAuthority(ctx context.Context, in *DeleteAuthorityRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
}

type authorityClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthorityClient(cc grpc.ClientConnInterface) AuthorityClient {
	return &authorityClient{cc}
}

func (c *authorityClient) GetAuthorityList(ctx context.Context, in *GetAuthorityListRequest, opts ...grpc.CallOption) (*GetAuthorityListResponse, error) {
	out := new(GetAuthorityListResponse)
	err := c.cc.Invoke(ctx, "/pb.Authority/GetAuthorityList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) AddAuthorityMenu(ctx context.Context, in *AddAuthorityMenuRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Authority/AddAuthorityMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) UpdateAuthority(ctx context.Context, in *UpdateAuthorityRequest, opts ...grpc.CallOption) (*UpdateAuthorityResponse, error) {
	out := new(UpdateAuthorityResponse)
	err := c.cc.Invoke(ctx, "/pb.Authority/UpdateAuthority", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) CreateAuthority(ctx context.Context, in *CreateAuthorityRequest, opts ...grpc.CallOption) (*CreateAuthorityResponse, error) {
	out := new(CreateAuthorityResponse)
	err := c.cc.Invoke(ctx, "/pb.Authority/CreateAuthority", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorityClient) DeleteAuthority(ctx context.Context, in *DeleteAuthorityRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Authority/DeleteAuthority", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthorityServer is the server API for Authority service.
// All implementations must embed UnimplementedAuthorityServer
// for forward compatibility
type AuthorityServer interface {
	// 获取角色列表
	GetAuthorityList(context.Context, *GetAuthorityListRequest) (*GetAuthorityListResponse, error)
	// 增加base_menu和角色关联关系 -- 用于角色管理的设置权限
	AddAuthorityMenu(context.Context, *AddAuthorityMenuRequest) (*NoDataResponse, error)
	// 更新角色 -- 设为首页
	UpdateAuthority(context.Context, *UpdateAuthorityRequest) (*UpdateAuthorityResponse, error)
	// 创建角色
	CreateAuthority(context.Context, *CreateAuthorityRequest) (*CreateAuthorityResponse, error)
	// 删除角色
	DeleteAuthority(context.Context, *DeleteAuthorityRequest) (*NoDataResponse, error)
	mustEmbedUnimplementedAuthorityServer()
}

// UnimplementedAuthorityServer must be embedded to have forward compatible implementations.
type UnimplementedAuthorityServer struct {
}

func (UnimplementedAuthorityServer) GetAuthorityList(context.Context, *GetAuthorityListRequest) (*GetAuthorityListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthorityList not implemented")
}
func (UnimplementedAuthorityServer) AddAuthorityMenu(context.Context, *AddAuthorityMenuRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAuthorityMenu not implemented")
}
func (UnimplementedAuthorityServer) UpdateAuthority(context.Context, *UpdateAuthorityRequest) (*UpdateAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAuthority not implemented")
}
func (UnimplementedAuthorityServer) CreateAuthority(context.Context, *CreateAuthorityRequest) (*CreateAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthority not implemented")
}
func (UnimplementedAuthorityServer) DeleteAuthority(context.Context, *DeleteAuthorityRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAuthority not implemented")
}
func (UnimplementedAuthorityServer) mustEmbedUnimplementedAuthorityServer() {}

// UnsafeAuthorityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthorityServer will
// result in compilation errors.
type UnsafeAuthorityServer interface {
	mustEmbedUnimplementedAuthorityServer()
}

func RegisterAuthorityServer(s grpc.ServiceRegistrar, srv AuthorityServer) {
	s.RegisterService(&Authority_ServiceDesc, srv)
}

func _Authority_GetAuthorityList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAuthorityListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).GetAuthorityList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Authority/GetAuthorityList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).GetAuthorityList(ctx, req.(*GetAuthorityListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_AddAuthorityMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAuthorityMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).AddAuthorityMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Authority/AddAuthorityMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).AddAuthorityMenu(ctx, req.(*AddAuthorityMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_UpdateAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).UpdateAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Authority/UpdateAuthority",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).UpdateAuthority(ctx, req.(*UpdateAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_CreateAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).CreateAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Authority/CreateAuthority",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).CreateAuthority(ctx, req.(*CreateAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authority_DeleteAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorityServer).DeleteAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Authority/DeleteAuthority",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorityServer).DeleteAuthority(ctx, req.(*DeleteAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Authority_ServiceDesc is the grpc.ServiceDesc for Authority service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Authority_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Authority",
	HandlerType: (*AuthorityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuthorityList",
			Handler:    _Authority_GetAuthorityList_Handler,
		},
		{
			MethodName: "AddAuthorityMenu",
			Handler:    _Authority_AddAuthorityMenu_Handler,
		},
		{
			MethodName: "UpdateAuthority",
			Handler:    _Authority_UpdateAuthority_Handler,
		},
		{
			MethodName: "CreateAuthority",
			Handler:    _Authority_CreateAuthority_Handler,
		},
		{
			MethodName: "DeleteAuthority",
			Handler:    _Authority_DeleteAuthority_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "application/applet/rpc/desc/applet.proto",
}

// ApiClient is the client API for Api service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiClient interface {
	// 获取API列表
	GetApiList(ctx context.Context, in *GetApiListRequest, opts ...grpc.CallOption) (*GetApiListResponse, error)
	// 创建/添加 API列表
	CreateApi(ctx context.Context, in *CreateApiRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 删除API列表
	DeleteApi(ctx context.Context, in *DeleteApiRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 获取全部API列表
	GetAllApiList(ctx context.Context, in *NoDataResponse, opts ...grpc.CallOption) (*GetAllApiListResponse, error)
	// 删除多条api
	DeleteApisByIds(ctx context.Context, in *DeleteApisByIdsRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 更新api
	UpdateApi(ctx context.Context, in *UpdateApiRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
}

type apiClient struct {
	cc grpc.ClientConnInterface
}

func NewApiClient(cc grpc.ClientConnInterface) ApiClient {
	return &apiClient{cc}
}

func (c *apiClient) GetApiList(ctx context.Context, in *GetApiListRequest, opts ...grpc.CallOption) (*GetApiListResponse, error) {
	out := new(GetApiListResponse)
	err := c.cc.Invoke(ctx, "/pb.Api/GetApiList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) CreateApi(ctx context.Context, in *CreateApiRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Api/CreateApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) DeleteApi(ctx context.Context, in *DeleteApiRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Api/DeleteApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) GetAllApiList(ctx context.Context, in *NoDataResponse, opts ...grpc.CallOption) (*GetAllApiListResponse, error) {
	out := new(GetAllApiListResponse)
	err := c.cc.Invoke(ctx, "/pb.Api/GetAllApiList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) DeleteApisByIds(ctx context.Context, in *DeleteApisByIdsRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Api/DeleteApisByIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) UpdateApi(ctx context.Context, in *UpdateApiRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Api/UpdateApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServer is the server API for Api service.
// All implementations must embed UnimplementedApiServer
// for forward compatibility
type ApiServer interface {
	// 获取API列表
	GetApiList(context.Context, *GetApiListRequest) (*GetApiListResponse, error)
	// 创建/添加 API列表
	CreateApi(context.Context, *CreateApiRequest) (*NoDataResponse, error)
	// 删除API列表
	DeleteApi(context.Context, *DeleteApiRequest) (*NoDataResponse, error)
	// 获取全部API列表
	GetAllApiList(context.Context, *NoDataResponse) (*GetAllApiListResponse, error)
	// 删除多条api
	DeleteApisByIds(context.Context, *DeleteApisByIdsRequest) (*NoDataResponse, error)
	// 更新api
	UpdateApi(context.Context, *UpdateApiRequest) (*NoDataResponse, error)
	mustEmbedUnimplementedApiServer()
}

// UnimplementedApiServer must be embedded to have forward compatible implementations.
type UnimplementedApiServer struct {
}

func (UnimplementedApiServer) GetApiList(context.Context, *GetApiListRequest) (*GetApiListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApiList not implemented")
}
func (UnimplementedApiServer) CreateApi(context.Context, *CreateApiRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApi not implemented")
}
func (UnimplementedApiServer) DeleteApi(context.Context, *DeleteApiRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApi not implemented")
}
func (UnimplementedApiServer) GetAllApiList(context.Context, *NoDataResponse) (*GetAllApiListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllApiList not implemented")
}
func (UnimplementedApiServer) DeleteApisByIds(context.Context, *DeleteApisByIdsRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApisByIds not implemented")
}
func (UnimplementedApiServer) UpdateApi(context.Context, *UpdateApiRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApi not implemented")
}
func (UnimplementedApiServer) mustEmbedUnimplementedApiServer() {}

// UnsafeApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiServer will
// result in compilation errors.
type UnsafeApiServer interface {
	mustEmbedUnimplementedApiServer()
}

func RegisterApiServer(s grpc.ServiceRegistrar, srv ApiServer) {
	s.RegisterService(&Api_ServiceDesc, srv)
}

func _Api_GetApiList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetApiListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetApiList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/GetApiList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetApiList(ctx, req.(*GetApiListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_CreateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateApiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).CreateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/CreateApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).CreateApi(ctx, req.(*CreateApiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_DeleteApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteApiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).DeleteApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/DeleteApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).DeleteApi(ctx, req.(*DeleteApiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_GetAllApiList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NoDataResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetAllApiList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/GetAllApiList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetAllApiList(ctx, req.(*NoDataResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_DeleteApisByIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteApisByIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).DeleteApisByIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/DeleteApisByIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).DeleteApisByIds(ctx, req.(*DeleteApisByIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_UpdateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateApiRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).UpdateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/UpdateApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).UpdateApi(ctx, req.(*UpdateApiRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Api_ServiceDesc is the grpc.ServiceDesc for Api service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Api_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Api",
	HandlerType: (*ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetApiList",
			Handler:    _Api_GetApiList_Handler,
		},
		{
			MethodName: "CreateApi",
			Handler:    _Api_CreateApi_Handler,
		},
		{
			MethodName: "DeleteApi",
			Handler:    _Api_DeleteApi_Handler,
		},
		{
			MethodName: "GetAllApiList",
			Handler:    _Api_GetAllApiList_Handler,
		},
		{
			MethodName: "DeleteApisByIds",
			Handler:    _Api_DeleteApisByIds_Handler,
		},
		{
			MethodName: "UpdateApi",
			Handler:    _Api_UpdateApi_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "application/applet/rpc/desc/applet.proto",
}

// CasbinClient is the client API for Casbin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CasbinClient interface {
	// 根据角色id获取对应的casbin数据
	GetPathByAuthorityId(ctx context.Context, in *GetPathByAuthorityIdRequest, opts ...grpc.CallOption) (*GetPathByAuthorityIdResponse, error)
	// 更新一个角色的对应的casbin数据
	UpdateCasbinData(ctx context.Context, in *UpdateCasbinDataRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
	// 更新一个角色的对应的casbin数据 用api的ids 查数据
	UpdateCasbinDataByApiIds(ctx context.Context, in *UpdateCasbinDataByApiIdsRequest, opts ...grpc.CallOption) (*NoDataResponse, error)
}

type casbinClient struct {
	cc grpc.ClientConnInterface
}

func NewCasbinClient(cc grpc.ClientConnInterface) CasbinClient {
	return &casbinClient{cc}
}

func (c *casbinClient) GetPathByAuthorityId(ctx context.Context, in *GetPathByAuthorityIdRequest, opts ...grpc.CallOption) (*GetPathByAuthorityIdResponse, error) {
	out := new(GetPathByAuthorityIdResponse)
	err := c.cc.Invoke(ctx, "/pb.Casbin/GetPathByAuthorityId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casbinClient) UpdateCasbinData(ctx context.Context, in *UpdateCasbinDataRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Casbin/UpdateCasbinData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casbinClient) UpdateCasbinDataByApiIds(ctx context.Context, in *UpdateCasbinDataByApiIdsRequest, opts ...grpc.CallOption) (*NoDataResponse, error) {
	out := new(NoDataResponse)
	err := c.cc.Invoke(ctx, "/pb.Casbin/UpdateCasbinDataByApiIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CasbinServer is the server API for Casbin service.
// All implementations must embed UnimplementedCasbinServer
// for forward compatibility
type CasbinServer interface {
	// 根据角色id获取对应的casbin数据
	GetPathByAuthorityId(context.Context, *GetPathByAuthorityIdRequest) (*GetPathByAuthorityIdResponse, error)
	// 更新一个角色的对应的casbin数据
	UpdateCasbinData(context.Context, *UpdateCasbinDataRequest) (*NoDataResponse, error)
	// 更新一个角色的对应的casbin数据 用api的ids 查数据
	UpdateCasbinDataByApiIds(context.Context, *UpdateCasbinDataByApiIdsRequest) (*NoDataResponse, error)
	mustEmbedUnimplementedCasbinServer()
}

// UnimplementedCasbinServer must be embedded to have forward compatible implementations.
type UnimplementedCasbinServer struct {
}

func (UnimplementedCasbinServer) GetPathByAuthorityId(context.Context, *GetPathByAuthorityIdRequest) (*GetPathByAuthorityIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPathByAuthorityId not implemented")
}
func (UnimplementedCasbinServer) UpdateCasbinData(context.Context, *UpdateCasbinDataRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCasbinData not implemented")
}
func (UnimplementedCasbinServer) UpdateCasbinDataByApiIds(context.Context, *UpdateCasbinDataByApiIdsRequest) (*NoDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCasbinDataByApiIds not implemented")
}
func (UnimplementedCasbinServer) mustEmbedUnimplementedCasbinServer() {}

// UnsafeCasbinServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CasbinServer will
// result in compilation errors.
type UnsafeCasbinServer interface {
	mustEmbedUnimplementedCasbinServer()
}

func RegisterCasbinServer(s grpc.ServiceRegistrar, srv CasbinServer) {
	s.RegisterService(&Casbin_ServiceDesc, srv)
}

func _Casbin_GetPathByAuthorityId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPathByAuthorityIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServer).GetPathByAuthorityId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Casbin/GetPathByAuthorityId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServer).GetPathByAuthorityId(ctx, req.(*GetPathByAuthorityIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Casbin_UpdateCasbinData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCasbinDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServer).UpdateCasbinData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Casbin/UpdateCasbinData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServer).UpdateCasbinData(ctx, req.(*UpdateCasbinDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Casbin_UpdateCasbinDataByApiIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCasbinDataByApiIdsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServer).UpdateCasbinDataByApiIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Casbin/UpdateCasbinDataByApiIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServer).UpdateCasbinDataByApiIds(ctx, req.(*UpdateCasbinDataByApiIdsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Casbin_ServiceDesc is the grpc.ServiceDesc for Casbin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Casbin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Casbin",
	HandlerType: (*CasbinServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPathByAuthorityId",
			Handler:    _Casbin_GetPathByAuthorityId_Handler,
		},
		{
			MethodName: "UpdateCasbinData",
			Handler:    _Casbin_UpdateCasbinData_Handler,
		},
		{
			MethodName: "UpdateCasbinDataByApiIds",
			Handler:    _Casbin_UpdateCasbinDataByApiIds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "application/applet/rpc/desc/applet.proto",
}
